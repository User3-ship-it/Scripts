-- CONVERTED BY FLIPONER
-- GONER MADE BY SOMEONE ELSE, THIS IS JUST A CONVERTED VERSION 


IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

do
local Accessories = {}
local Aligns = {}
local Attachments = {}
local BindableEvent = nil
local Blacklist = {}
local CFrame = CFrame
local CFrameidentity = CFrame.identity
local CFramelookAt = CFrame.lookAt
local CFramenew = CFrame.new
local Character = nil
local CurrentCamera = nil
local Enum = Enum
local Custom = Enum.CameraType.Custom
local Health = Enum.CoreGuiType.Health
local HumanoidRigType = Enum.HumanoidRigType
setfpscap(144)
local Dead = Enum.HumanoidStateType.Dead
local LockCenter = Enum.MouseBehavior.LockCenter
local MouseButton1 = Enum.UserInputType.MouseButton1
local Exceptions = {}
local game = game
local Clone = game.Clone
local Close = game.Close
local Connect = Close.Connect
local Disconnect = Connect(Close, function() end).Disconnect
local Wait = Close.Wait
local Destroy = game.Destroy
local FindFirstAncestorOfClass = game.FindFirstAncestorOfClass
local FindFirstAncestorWhichIsA = game.FindFirstAncestorWhichIsA
local FindFirstChild = game.FindFirstChild
local FindFirstChildOfClass = game.FindFirstChildOfClass
local Players = FindFirstChildOfClass(game, "Players")
local CreateHumanoidModelFromDescription = Players.CreateHumanoidModelFromDescription
local GetPlayers = Players.GetPlayers
local LocalPlayer = Players.LocalPlayer
local CharacterAdded = LocalPlayer.CharacterAdded
local ConnectDiedSignalBackend = LocalPlayer.ConnectDiedSignalBackend
local Mouse = LocalPlayer:GetMouse()
local Kill = LocalPlayer.Kill
local RunService = FindFirstChildOfClass(game, "RunService")
local PostSimulation = RunService.PostSimulation
local PreRender = RunService.PreRender
local PreSimulation = RunService.PreSimulation
local StarterGui = FindFirstChildOfClass(game, "StarterGui")
local GetCoreGuiEnabled = StarterGui.GetCoreGuiEnabled
local SetCore = StarterGui.SetCore
local SetCoreGuiEnabled = StarterGui.SetCoreGuiEnabled
local Workspace = FindFirstChildOfClass(game, "Workspace")
local FallenPartsDestroyHeight = Workspace.FallenPartsDestroyHeight
local HatDropY = FallenPartsDestroyHeight - 0.7
local FindFirstChildWhichIsA = game.FindFirstChildWhichIsA
local UserInputService = FindFirstChildOfClass(game, "UserInputService")
local InputBegan = UserInputService.InputBegan
local IsMouseButtonPressed = UserInputService.IsMouseButtonPressed
local GetChildren = game.GetChildren
local GetDescendants = game.GetDescendants
local GetPropertyChangedSignal = game.GetPropertyChangedSignal
local CurrentCameraChanged = GetPropertyChangedSignal(Workspace, "CurrentCamera")
local MouseBehaviorChanged = GetPropertyChangedSignal(UserInputService, "MouseBehavior")
local IsA = game.IsA
local IsDescendantOf = game.IsDescendantOf
local Highlights = {}
local Instancenew = Instance.new
local Animation = Instance.new("Animation")
local HumanoidDescription = Instancenew("HumanoidDescription")
local HumanoidModel = CreateHumanoidModelFromDescription(Players, HumanoidDescription, HumanoidRigType.R6)
local R15HumanoidModel = CreateHumanoidModelFromDescription(Players, HumanoidDescription, HumanoidRigType.R15)
local SetAccessories = HumanoidDescription.SetAccessories
local ModelBreakJoints = HumanoidModel.BreakJoints
local Head = HumanoidModel.Head
local BasePartBreakJoints = Head.BreakJoints
local GetJoints = Head.GetJoints
local IsGrounded = Head.IsGrounded
local Humanoid = HumanoidModel.Humanoid
local ApplyDescription = Humanoid.ApplyDescription
local ChangeState = Humanoid.ChangeState
local EquipTool = Humanoid.EquipTool
local GetAppliedDescription = Humanoid.GetAppliedDescription
local GetPlayingAnimationTracks = Humanoid.GetPlayingAnimationTracks
local LoadAnimation = Humanoid.LoadAnimation
local Move = Humanoid.Move
local UnequipTools = Humanoid.UnequipTools
local ScaleTo = HumanoidModel.ScaleTo
local IsFirst = false
local IsHealthEnabled = nil
local IsLockCenter = false
local IsRegistered = false
local IsRunning = false
local LastTime = nil
local math = math
local mathrandom = math.random
local mathsin = math.sin
local nan = 0 / 0
local next = next

local OptionsAccessories = nil
local OptionsApplyDescription = nil
local OptionsBreakJointsDelay = nil
local OptionsClickFling = nil
local OptionsDisableCharacterCollisions = nil
local OptionsDisableHealthBar = nil
local OptionsDisableRigCollisions = nil
OptionsDefaultFlingOptions = {
	FlingVelocity = Vector3.new(500, 500, 500),
	PredictionFling = true,
	HatFling = false,      -- whether to fling hats
	ToolFling = false,     -- whether to fling tools
	Highlight = true      -- show highlight on target
}


local OptionsHatDrop = nil
local OptionsHideCharacter = nil
local OptionsParentCharacter = nil
local OptionsPermanentDeath = nil
local OptionsRefit = nil
local OptionsRigTransparency = nil
local OptionsSetCameraSubject = nil
local OptionsSetCameraType = nil
local OptionsSetCharacter = nil
local OptionsSetCollisionGroup = nil
local OptionsSimulationRadius = nil
local OptionsTeleportRadius = nil

local osclock = os.clock
local PreRenderConnection = nil
local RBXScriptConnections = {}
local Refitting = false
local replicatesignal = replicatesignal
local Rig = nil
local RigHumanoid = nil
local RigHumanoidRootPart = nil
local sethiddenproperty = sethiddenproperty
local setscriptable = setscriptable
local stringfind = string.find
local table = table
local tableclear = table.clear
local tablefind = table.find
local tableinsert = table.insert
local tableremove = table.remove

local Targets = {}

local task = task
local taskdefer = task.defer
local taskspawn = task.spawn
local taskwait = task.wait
local Time = nil

local Vector3 = Vector3
local Vector3new = Vector3.new
local FlingVelocity = Vector3new(16384, 16384, 16384)
local HatDropLinearVelocity = Vector3new(0, 27, 0)
local Vector3one = Vector3.one
local Vector3xzAxis = Vector3new(1, 0, 1)
local Vector3zero = Vector3.zero
local AntiSleep = Vector3zero

Animation.AnimationId = "rbxassetid://180436148"

Humanoid = nil

Destroy(HumanoidDescription)
HumanoidDescription = nil

local FindFirstChildOfClassAndName = function(Parent, ClassName, Name)
for Index, Child in next, GetChildren(Parent) do
if IsA(Child, ClassName) and Child.Name == Name then
return Child
end
end
end

local GetHandleFromTable = function(Table)
for Index, Child in GetChildren(Character) do
if IsA(Child, "Accoutrement") then
local Handle = FindFirstChildOfClassAndName(Child, "BasePart", "Handle")

if Handle then
local MeshId = nil
local TextureId = nil

if IsA(Handle, "MeshPart") then
MeshId = Handle.MeshId
TextureId = Handle.TextureID
else
local SpecialMesh = FindFirstChildOfClass(Handle, "SpecialMesh")

if SpecialMesh then
MeshId = SpecialMesh.MeshId
TextureId = SpecialMesh.TextureID
end
end

if MeshId then
if stringfind(MeshId, Table.MeshId) and stringfind(TextureId, Table.TextureId) then
return Handle
end
end
end
end
end
end

local NewIndex = function(self, Index, Value)
self[Index] = Value
end

local DescendantAdded = function(Descendant)
if IsA(Descendant, "Accoutrement") and OptionsHatDrop then
if not pcall(NewIndex, Descendant, "BackendAccoutrementState", 0) then
if sethiddenproperty then
sethiddenproperty(Descendant, "BackendAccoutrementState", 0)
elseif setscriptable then
setscriptable(Descendant, "BacekndAccoutrementState", true)
Descendant.BackendAccoutrementState = 0
end
end
elseif IsA(Descendant, "Attachment") then
local Attachment = Attachments[Descendant.Name]

if Attachment then
local Parent = Descendant.Parent

if IsA(Parent, "BasePart") then
local MeshId = nil
local TextureId = nil

if IsA(Parent, "MeshPart") then
MeshId = Parent.MeshId
TextureId = Parent.TextureID
else
local SpecialMesh = FindFirstChildOfClass(Parent, "SpecialMesh")

if SpecialMesh then
MeshId = SpecialMesh.MeshId
TextureId = SpecialMesh.TextureId
end
end

if MeshId then
for Index, Table in next, Accessories do
if Table.MeshId == MeshId and Table.TextureId == TextureId then
local Handle = Table.Handle

tableinsert(Aligns, {
LastPosition = Handle.Position,
Offset = CFrameidentity,
Part0 = Parent,
Part1 = Handle
})

return
end
end

for Index, Table in next, OptionsAccessories do
if stringfind(MeshId, Table.MeshId) and stringfind(TextureId, Table.TextureId) then
local Instance = nil
local TableName = Table.Name
local TableNames = Table.Names

if TableName then
Instance = FindFirstChildOfClassAndName(Rig, "BasePart", TableName)
else
for Index, TableName in next, TableNames do
local Child = FindFirstChildOfClassAndName(Rig, "BasePart", TableName)

if not ( TableNames[Index + 1] and Blacklist[Child] ) then
Instance = Child
break
end
end
end

if Instance then
local Blacklisted = Blacklist[Instance]

if not ( Blacklisted and Blacklisted.MeshId == MeshId and Blacklisted.TextureId == TextureId ) then
tableinsert(Aligns, {
LastPosition = Instance.Position,
Offset = Table.Offset,
Part0 = Parent,
Part1 = Instance
})

Blacklist[Instance] = { MeshId = MeshId, TextureId = TextureId }

return
end
end
end
end

local Accoutrement = FindFirstAncestorWhichIsA(Parent, "Accoutrement")

if Accoutrement and IsA(Accoutrement, "Accoutrement") then
local AccoutrementClone = Clone(Accoutrement)

local HandleClone = FindFirstChildOfClassAndName(AccoutrementClone, "BasePart", "Handle")
HandleClone.Transparency = OptionsRigTransparency

for Index, Descendant in next, GetDescendants(HandleClone) do
if IsA(Descendant, "JointInstance") then
Destroy(Descendant)
end
end

local AccessoryWeld = Instancenew("Weld")
AccessoryWeld.C0 = Descendant.CFrame
AccessoryWeld.C1 = Attachment.CFrame
AccessoryWeld.Name = "AccessoryWeld"
AccessoryWeld.Part0 = HandleClone
AccessoryWeld.Part1 = Attachment.Parent
AccessoryWeld.Parent = HandleClone

AccoutrementClone.Parent = Rig

tableinsert(Accessories, {
Handle = HandleClone,
MeshId = MeshId,
TextureId = TextureId
})
tableinsert(Aligns, {
LastPosition = HandleClone.Position,
Offset = CFrameidentity,
Part0 = Parent,
Part1 = HandleClone
})
end
end
end
end
end
end

local SetCameraSubject = function()
local CameraCFrame = CurrentCamera.CFrame
local Position = RigHumanoidRootPart.CFrame.Position

CurrentCamera.CameraSubject = RigHumanoid
Wait(PreRender)
CurrentCamera.CFrame = CameraCFrame + RigHumanoidRootPart.CFrame.Position - Position
end

local OnCameraSubjectChanged = function()
if CurrentCamera.CameraSubject ~= RigHumanoid then
taskdefer(SetCameraSubject)
end
end

local OnCameraTypeChanged = function()
if CurrentCamera.CameraType ~= Custom then
CurrentCamera.CameraType = Custom
end
end

local OnCurrentCameraChanged = function()
local Camera = Workspace.CurrentCamera

if Camera and OptionsSetCameraSubject then
CurrentCamera = Workspace.CurrentCamera

taskspawn(SetCameraSubject)

OnCameraSubjectChanged()
tableinsert(RBXScriptConnections, Connect(GetPropertyChangedSignal(CurrentCamera, "CameraSubject"), OnCameraSubjectChanged))

if OptionsSetCameraType then
OnCameraTypeChanged()
tableinsert(RBXScriptConnections, Connect(GetPropertyChangedSignal(CurrentCamera, "CameraType"), OnCameraTypeChanged))
end
end
end

local SetCharacter = function()
LocalPlayer.Character = Rig
end

local SetSimulationRadius = function()
LocalPlayer.SimulationRadius = OptionsSimulationRadius
end

local WaitForChildOfClass = function(Parent, ClassName)
local Child = FindFirstChildOfClass(Parent, ClassName)

while not Child do
Wait(Parent.ChildAdded)
Child = FindFirstChildOfClass(Parent, ClassName)
end

return Child
end

local WaitForChildOfClassAndName = function(Parent, ...)
local Child = FindFirstChildOfClassAndName(Parent, ...)

while not Child do
Wait(Parent.ChildAdded)
Child = FindFirstChildOfClassAndName(Parent, ...)
end

return Child
end

local Fling = function(Target, Options)
if Target then
local Highlight = true

if IsA(Target, "Humanoid") then
Target = Target.Parent
end
if IsA(Target, "Model") then
Target = FindFirstChildOfClassAndName(Target, "BasePart", "HumanoidRootPart") or FindFirstChildWhichIsA(Character, "BasePart")
end

if not tablefind(Targets, Target) and IsA(Target, "BasePart") and not Target.Anchored and not IsDescendantOf(Character, Target) and not IsDescendantOf(Rig, Target) then
local Model = FindFirstAncestorOfClass(Target, "Model")

if Model and FindFirstChildOfClass(Model, "Humanoid") then
Target = FindFirstChildOfClassAndName(Model, "BasePart", "HumanoidRootPart") or FindFirstChildWhichIsA(Character, "BasePart") or Target	
else
Model = Target
end

if Highlight then
local HighlightObject = type(Highlight) == "boolean" and Highlight and Instancenew("Highlight") or Clone(Highlight)
HighlightObject.Adornee = Model
HighlightObject.Parent = Model

--Options.HighlightObject = HighlightObject
tableinsert(Highlights, HighlightObject)
end

Targets[Target] = Options

if not OptionsDefaultFlingOptions.HatFling and OptionsPermanentDeath and replicatesignal then
replicatesignal(ConnectDiedSignalBackend)
end
end
end
end


local OnCharacterAdded = function(NewCharacter)

if NewCharacter ~= Rig then
tableclear(Aligns)
tableclear(Blacklist)

Character = NewCharacter

if OptionsSetCameraSubject then
taskspawn(SetCameraSubject)
end

if OptionsSetCharacter then
taskdefer(SetCharacter)
end

if OptionsParentCharacter then
Character.Parent = Rig
end

for Index, Descendant in next, GetDescendants(Character) do
taskspawn(DescendantAdded, Descendant)
end

tableinsert(RBXScriptConnections, Connect(Character.DescendantAdded, DescendantAdded))

Humanoid = WaitForChildOfClass(Character, "Humanoid")
local HumanoidRootPart = WaitForChildOfClassAndName(Character, "BasePart", "HumanoidRootPart")

if IsFirst then
if OptionsApplyDescription and Humanoid then
local AppliedDescription = GetAppliedDescription(Humanoid)
SetAccessories(AppliedDescription, {}, true)
ApplyDescription(RigHumanoid, AppliedDescription)
end

if HumanoidRootPart then
RigHumanoidRootPart.CFrame = HumanoidRootPart.CFrame

if OptionsSetCollisionGroup then
local CollisionGroup = HumanoidRootPart.CollisionGroup

for Index, Descendant in next, GetDescendants(Rig) do
if IsA(Descendant, "BasePart") then
Descendant.CollisionGroup = CollisionGroup
end
end
end
end

IsFirst = false
end

local IsAlive = true

if HumanoidRootPart then
for Target, Options in next, Targets do
if IsDescendantOf(Target, Workspace) then
local FirstPosition = Target.Position
local PredictionFling = Options.PredictionFling
local LastPosition = FirstPosition
local Timeout = osclock() + 1

if HumanoidRootPart then
while IsDescendantOf(Target, Workspace) and osclock() < Timeout do
local DeltaTime = taskwait()
local Position = Target.Position

if ( Position - FirstPosition ).Magnitude > 100 then
break
end

local Offset = Vector3zero

if PredictionFling then
Vector3zero = ( Position - LastPosition ) / DeltaTime * 0.13
end

HumanoidRootPart.AssemblyAngularVelocity = FlingVelocity
HumanoidRootPart.AssemblyLinearVelocity = FlingVelocity

HumanoidRootPart.CFrame = Target.CFrame + Offset
LastPosition = Position
end
end
end

local HighlightObject = Options.HighlightObject

if HighlightObject then
Destroy(HighlightObject)
end

Targets[Target] = nil
end

HumanoidRootPart.AssemblyAngularVelocity = Vector3zero
HumanoidRootPart.AssemblyLinearVelocity = Vector3zero

if OptionsHatDrop then
taskspawn(function()
WaitForChildOfClassAndName(Character, "LocalScript", "Animate").Enabled = false

for Index, AnimationTrack in next, GetPlayingAnimationTracks(Humanoid) do
AnimationTrack:Stop()
end

LoadAnimation(Humanoid, Animation):Play(0)

pcall(NewIndex, Workspace, "FallenPartsDestroyHeight", nan)

local RootPartCFrame = RigHumanoidRootPart.CFrame
RootPartCFrame = CFramenew(RootPartCFrame.X, HatDropY, RootPartCFrame.Z)

while IsAlive do
HumanoidRootPart.AssemblyAngularVelocity = Vector3zero
HumanoidRootPart.AssemblyLinearVelocity = HatDropLinearVelocity
HumanoidRootPart.CFrame = RootPartCFrame

taskwait()
end
end)
elseif OptionsHideCharacter then
local RootPartCFrame = RigHumanoidRootPart.CFrame - Vector3new(0, 45, 0)

taskspawn(function()
while IsAlive do
HumanoidRootPart.AssemblyAngularVelocity = Vector3zero
HumanoidRootPart.AssemblyLinearVelocity = Vector3zero
HumanoidRootPart.CFrame = RootPartCFrame

taskwait()
end
end)
elseif OptionsTeleportRadius then
HumanoidRootPart.CFrame = RigHumanoidRootPart.CFrame + Vector3new(mathrandom(- OptionsTeleportRadius, OptionsTeleportRadius), 0, mathrandom(- OptionsTeleportRadius, OptionsTeleportRadius))
end
end



if OptionsPermanentDeath and replicatesignal then
replicatesignal(ConnectDiedSignalBackend)

taskwait(Players.RespawnTime + 0.1)

Refitting = false
replicatesignal(Kill)
else
taskwait(OptionsBreakJointsDelay)
end

ModelBreakJoints(Character)

if Humanoid then
ChangeState(Humanoid, Dead)
Wait(Humanoid.Died)
end

IsAlive = false

if OptionsHatDrop then
pcall(NewIndex, Workspace, "FallenPartsDestroyHeight", FallenPartsDestroyHeight)
end
end
end

local OnInputBegan = function(InputObject)
if InputObject.UserInputType == MouseButton1 then
local Target = Mouse.Target

local HatFling = OptionsDefaultFlingOptions.HatFling
local ToolFling = OptionsDefaultFlingOptions.ToolFling

if HatFling and OptionsHatDrop then
local Part = type(HatFling) == "table" and GetHandleFromTable(HatFling)

if not Part then
for Index, Child in GetChildren(Character) do
if IsA(Child, "Accoutrement") then
local Handle = FindFirstChildOfClassAndName(Child, "BasePart", "Handle")

if Handle then
Part = Handle
break
end
end
end
end

if Part then
Exceptions[Part] = true

while IsMouseButtonPressed(UserInputService, MouseButton1) do
if Part.ReceiveAge == 0 then
Part.AssemblyAngularVelocity = FlingVelocity
Part.AssemblyLinearVelocity = FlingVelocity
Part.CFrame = Mouse.Hit + AntiSleep
end

taskwait()
end

Exceptions[Part] = false
end
elseif ToolFling then
local Backpack = FindFirstChildOfClass(LocalPlayer, "Backpack")
local Tool = nil

if type(ToolFling) == "string" then
Tool = FindFirstChild(Backpack, ToolFling) or FindFirstChild(Character, ToolFling)
end

if not Tool then
Tool = FindFirstChildOfClass(Backpack, "Tool") or FindFirstChildOfClass(Character, "Tool")
end

if Tool then
local Handle = FindFirstChildOfClassAndName(Tool, "BasePart", "Handle") or FindFirstChildWhichIsA(Tool, "BasePart")

if Handle then
UnequipTools(Humanoid)
taskwait()
EquipTool(Humanoid, Tool)

while IsMouseButtonPressed(UserInputService, MouseButton1) do
if Handle.ReceiveAge == 0 then
Handle.AssemblyAngularVelocity = FlingVelocity
Handle.AssemblyLinearVelocity = FlingVelocity
Handle.CFrame = Mouse.Hit + AntiSleep
end

taskwait()
end

UnequipTools(Humanoid)

Handle.AssemblyAngularVelocity = Vector3zero
Handle.AssemblyLinearVelocity = Vector3zero
Handle.CFrame = RigHumanoidRootPart.CFrame
end
end
else
Fling(Target, OptionsDefaultFlingOptions)
end
end
end

local OnPostSimulation = function()
Time = osclock()
local DeltaTime = Time - LastTime
LastTime = Time

if not OptionsSetCharacter and IsLockCenter then
local Position = RigHumanoidRootPart.Position
RigHumanoidRootPart.CFrame = CFramelookAt(Position, Position + CurrentCamera.CFrame.LookVector * Vector3xzAxis)
end

if OptionsSimulationRadius then
pcall(SetSimulationRadius)
end

AntiSleep = mathsin(Time * 15) * 0.0015 * Vector3one
local Axis = 27 + mathsin(Time)

for Index, Table in next, Aligns do
local Part0 = Table.Part0

if not Exceptions[Part0] then
if Part0.ReceiveAge == 0 then
if IsDescendantOf(Part0, Workspace) and not GetJoints(Part0)[1] and not IsGrounded(Part0) then
local Part1 = Table.Part1

Part0.AssemblyAngularVelocity = Vector3zero

local Position = Part1.Position
local LinearVelocity = ( Position - Table.LastPosition ) / DeltaTime * Axis
Part0.AssemblyLinearVelocity = Vector3new(LinearVelocity.X, Axis, LinearVelocity.Z)
Table.LastPosition = Position

Part0.CFrame = Part1.CFrame * Table.Offset + AntiSleep
end
else
local Frames = Table.Frames or - 1
Frames = Frames + 1
Table.Frames = Frames

if Frames > 15 and OptionsPermanentDeath and OptionsRefit and replicatesignal then
Refitting = false
replicatesignal(ConnectDiedSignalBackend)
end
end
end
end

if not OptionsSetCharacter and Humanoid then
Move(RigHumanoid, Humanoid.MoveDirection)
RigHumanoid.Jump = Humanoid.Jump
end

if IsRegistered then
SetCore(StarterGui, "ResetButtonCallback", BindableEvent)
else
IsRegistered = pcall(SetCore, StarterGui, "ResetButtonCallback", BindableEvent)
end
end

local OnPreRender = function()
local Position = RigHumanoidRootPart.Position
RigHumanoidRootPart.CFrame = CFramelookAt(Position, Position + CurrentCamera.CFrame.LookVector * Vector3xzAxis)

for Index, Table in next, Aligns do
local Part0 = Table.Part0

if Part0.ReceiveAge == 0 and IsDescendantOf(Part0, Workspace) and not GetJoints(Part0)[1] and not IsGrounded(Part0) then
Part0.CFrame = Table.Part1.CFrame * Table.Offset
end
end
end

local OnMouseBehaviorChanged = function()
IsLockCenter = UserInputService.MouseBehavior == LockCenter

if IsLockCenter then
PreRenderConnection = Connect(PreRender, OnPreRender)
tableinsert(RBXScriptConnections, PreRenderConnection)
elseif PreRenderConnection then
Disconnect(PreRenderConnection)
tableremove(RBXScriptConnections, tablefind(RBXScriptConnections, PreRenderConnection))
end
end

local OnPreSimulation = function()
if OptionsDisableCharacterCollisions and Character then
for Index, Descendant in next, GetDescendants(Character) do
if IsA(Descendant, "BasePart") then
Descendant.CanCollide = false
end
end
end
if OptionsDisableRigCollisions then
for Index, Descendant in next, GetChildren(Rig) do
if IsA(Descendant, "BasePart") then
Descendant.CanCollide = false
end
end
end
end

Start = function(Options)
if not IsRunning then
IsFirst = true
IsRunning = true

Options = Options or {}
OptionsAccessories = Options.Accessories or {}
OptionsApplyDescription = Options.ApplyDescription
OptionsBreakJointsDelay = Options.BreakJointsDelay or 0
OptionsClickFling = Options.ClickFling
OptionsDisableCharacterCollisions = Options.DisableCharacterCollisions
OptionsDisableHealthBar = Options.DisableHealthBar
OptionsDisableRigCollisions = Options.DisableRigCollisions
OptionsDefaultFlingOptions = Options.DefaultFlingOptions-- or {}
OptionsHatDrop = Options.HatDrop
OptionsHideCharacter = Options.HideCharacter
OptionsParentCharacter = Options.ParentCharacter
OptionsPermanentDeath = Options.PermanentDeath
OptionsRefit = Options.Refit
local OptionsRigSize = Options.RigSize
OptionsRigTransparency = Options.RigTransparency or 1
OptionsSetCameraSubject = Options.SetCameraSubject
OptionsSetCameraType = Options.SetCameraType
OptionsSetCharacter = Options.SetCharacter
OptionsSetCollisionGroup = Options.SetCollisionGroup
OptionsSimulationRadius = Options.SimulationRadius
OptionsTeleportRadius = Options.TeleportRadius

if OptionsDisableHealthBar then
IsHealthEnabled = GetCoreGuiEnabled(StarterGui, Health)
SetCoreGuiEnabled(StarterGui, Health, false)
end

BindableEvent = Instancenew("BindableEvent")
tableinsert(RBXScriptConnections, Connect(BindableEvent.Event, Stop))

Rig = Options.R15 and Clone(R15HumanoidModel) or Clone(HumanoidModel)
Rig.Name = "non"
RigHumanoid = Rig.Humanoid
RigHumanoidRootPart = Rig.HumanoidRootPart
Rig.Parent = Workspace

local Wing = Instance.new("Part", Rig)
Wing.Name = "Wing"
Wing.CanCollide = false

for Index, Descendant in next, GetDescendants(Rig) do
if IsA(Descendant, "Attachment") then
Attachments[Descendant.Name] = Descendant
elseif IsA(Descendant, "BasePart") or IsA(Descendant, "Decal") then
Descendant.Transparency = OptionsRigTransparency
end
end

if OptionsRigSize then
ScaleTo(Rig, OptionsRigSize)

RigHumanoid.JumpPower = 50
RigHumanoid.WalkSpeed = 16
end

OnCurrentCameraChanged()
tableinsert(RBXScriptConnections, Connect(CurrentCameraChanged, OnCurrentCameraChanged))

if OptionsClickFling then
tableinsert(RBXScriptConnections, Connect(InputBegan, OnInputBegan))
end

local Character = LocalPlayer.Character

if Character then
OnCharacterAdded(Character)
end

tableinsert(RBXScriptConnections, Connect(CharacterAdded, OnCharacterAdded))

LastTime = osclock()
tableinsert(RBXScriptConnections, Connect(PostSimulation, OnPostSimulation))

if not OptionsSetCharacter then
OnMouseBehaviorChanged()
tableinsert(RBXScriptConnections, Connect(MouseBehaviorChanged, OnMouseBehaviorChanged))
end

if OptionsDisableCharacterCollisions or OptionsDisableRigCollisions then
OnPreSimulation()
tableinsert(RBXScriptConnections, Connect(PreSimulation, OnPreSimulation))
end

return {
BindableEvent = BindableEvent,
Fling = Fling,
Rig = Rig
}
end
end

Stop = function()
if IsRunning then
IsFirst = false
IsRunning = false

for Index, Highlight in Highlights do
Destroy(Highlight)
end

tableclear(Highlights)

for Index, RBXScriptConnection in next, RBXScriptConnections do
Disconnect(RBXScriptConnection)
end

--//=================================\\
--|| 		   CLERPING
--\\=================================//

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end


tableclear(RBXScriptConnections)

Destroy(BindableEvent)

if Character.Parent == Rig then
Character.Parent = Workspace
end

if Humanoid then
ChangeState(Humanoid, Dead)
end

Destroy(Rig)

if OptionsPermanentDeath and replicatesignal then
replicatesignal(ConnectDiedSignalBackend)
end

if OptionsDisableHealthBar and not GetCoreGuiEnabled(StarterGui, Health) then
SetCoreGuiEnabled(StarterGui, Health, IsHealthEnabled)
end

if IsRegistered then
pcall(SetCore, StarterGui, "ResetButtonCallback", true)
else
IsRegistered = pcall(SetCore, StarterGui, "ResetButtonCallback", true)
end
end
end
end

local Rad = math.rad

Empyrean = Start({
Accessories = {
--{ MeshId = "", Name = "", Offset = CFrame.identity, TextureId = "" },
-- SB Rig
{ MeshId = "125443585075666", Name = "Torso", Offset = CFrame.Angles(0, 3.15, 0), TextureId = "121023324229475" },
{ MeshId = "121342985816617", Name = "Left Arm", Offset = CFrame.Angles(0, 0, 1.57), TextureId = "129264637819824" },
{ MeshId = "121342985816617", Name = "Right Arm", Offset = CFrame.Angles(0, 3.15, 1.57), TextureId = "129264637819824" },
{ MeshId = "83395427313429", Names = { "Left Leg", "Right Leg" }, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "97148121718581" },--18641142410

-- Free Rig
{ MeshId = "4819720316", Name = "Torso", Offset = CFrame.Angles(0, 0, -0.25), TextureId = "4819722776" },
{ MeshId = "3030546036", Name = "Left Arm", Offset = CFrame.Angles(-1.57, 0, 1.57), TextureId = "3033903209" },
{ MeshId = "3030546036", Name = "Right Arm", Offset = CFrame.Angles(-1.57, 0, -1.57), TextureId = "3360978739" },
{ MeshId = "3030546036", Name = "Left Leg", Offset = CFrame.Angles(-1.57, 0, 1.57), TextureId = "3033898741" },
{ MeshId = "3030546036", Name = "Right Leg", Offset = CFrame.Angles(-1.57, 0, -1.57), TextureId = "3409604993" },

-- Prosthetics
{ MeshId = "117554824897780", Name = "Right Leg", Offset = CFrame.Angles(0, -1.57, 0), TextureId = "99077561039115" },
{ MeshId = "123388937940630", Name = "Left Leg", Offset = CFrame.Angles(0, 1.57, 0), TextureId = "99077561039115" },
{ MeshId = "117554824897780", Name = "Right Leg", Offset = CFrame.Angles(0, -1.57, 0), TextureId = "84429400539007" },
{ MeshId = "123388937940630", Name = "Left Leg", Offset = CFrame.Angles(0, 1.57, 0), TextureId = "84429400539007" },

-- Classic Cheap Rig
{ MeshId = "12344206657", Name = "Left Arm", Offset = CFrame.new(0.05, 0.05, -0.075) * CFrame.Angles(-2, 0, 0), TextureId = "12344206675" },
{ MeshId = "12344207333", Name = "Right Arm", Offset = CFrame.new(-0.05, 0.05, -0.075) * CFrame.Angles(-1.95, 0, 0), TextureId = "12344207341" },
{ MeshId = "11159370334", Name = "Left Leg", Offset = CFrame.Angles(1.57, 1.57, 0), TextureId = "11159284657" },
{ MeshId = "11263221350", Name = "Right Leg", Offset = CFrame.Angles(1.57, -1.57, 0), TextureId = "11263219250" },

-- Grey Mesh Rig 
{ MeshId = "127552124837034", Names = {"Torso"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "131014325980101" },--14255556501
{ MeshId = "117287001096396", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "120169691545791" },--14255556501
{ MeshId = "121304376791439", Names = { "Left Leg", "Right Leg" }, Offset = CFrame.Angles(0, 0, 0), TextureId = "131014325980101" },--18641142410

-- offsale below
-- Classical Products rig (white/black arms)
{ MeshId = "14241018198", Names = {"Torso"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "14251599953" },
{ MeshId = "17374767929", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "17374768001" },
{ MeshId = "17387586286", Names = { "Left Leg", "Right Leg" }, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "17387586304" },
{ MeshId = "14255522247", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "14255543546" },
-- Noob Rig
{ MeshId = "18640899369", Name = "Torso", Offset = CFrame.Angles(0, 0, 0), TextureId = "18640899481" },
{ MeshId = "18640914129", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "18640914168" },
{ MeshId = "18640901641", Names = { "Left Leg", "Right Leg"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "18640901676" },
-- request
{ MeshId = "14768666349", Name = "Torso", Offset = CFrame.Angles(0, 0, 0), TextureId = "14768664565" },
{ MeshId = "14768684979", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "14768683674" },

{ MeshId = "133430149511748", Name = "Wing", Offset = CFrame.new(4, 0, 1) * CFrame.Angles(0, 0, 0), TextureId = "106380905898254" },

-- Grey Mesh Rig 
{ MeshId = "127552124837034", Names = {"Torso"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "131014325980101" },--14255556501
{ MeshId = "117287001096396", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "120169691545791" },--14255556501
{ MeshId = "121304376791439", Names = { "Left Leg", "Right Leg" }, Offset = CFrame.Angles(0, 0, 0), TextureId = "131014325980101" },--18641142410
-- Classical Products rig (white/black arms)
{ MeshId = "14241018198", Names = {"Torso"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "14251599953" },
{ MeshId = "17374767929", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "17374768001" },
{ MeshId = "17387586286", Names = { "Left Leg", "Right Leg" }, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "17387586304" },
{ MeshId = "14255522247", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "14255543546" },
-- Noob Rig
{ MeshId = "18640899369", Name = "Torso", Offset = CFrame.Angles(0, 0, 0), TextureId = "18640899481" },
{ MeshId = "18640914129", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "18640914168" },
{ MeshId = "18640901641", Names = { "Left Leg", "Right Leg"}, Offset = CFrame.Angles(0, 0, 0), TextureId = "18640901676" },
-- Genesis Black Rig
{ MeshId = "110684113028749", Name = "Torso", Offset = CFrame.identity, TextureId = "70661572547971" },
{ MeshId = "125405780718494", Name = "Left Arm", Offset = CFrame.Angles(0, 0,  Rad(90)), TextureId = "136752500636691" },
{ MeshId = "125405780718494", Name = "Right Arm", Offset = CFrame.Angles(0, 0,  Rad(90)), TextureId = "136752500636691" },
{ MeshId = "125405780718494", Name = "Left Leg", Offset = CFrame.Angles(0, 0, Rad(90)), TextureId = "136752500636691" },
{ MeshId = "125405780718494", Name = "Right Leg", Offset = CFrame.Angles(0, 0,  Rad(90)), TextureId = "136752500636691" },
-- Genesis White Rig
{ MeshId = "126825022897778", Name = "Torso", Offset = CFrame.identity, TextureId = "130689541138804" },
{ MeshId = "99608462237958", Name = "Left Arm", Offset = CFrame.Angles(0, 0,  Rad(90)), TextureId = "130809869695496" },
{ MeshId = "139733645770094", Name = "Right Arm", Offset = CFrame.Angles(0, 0,  Rad(90)), TextureId = "130809869695496" },
{ MeshId = "105141400603933", Name = "Left Leg", Offset = CFrame.Angles(0, 0, Rad(90)), TextureId = "71060417496309" },
{ MeshId = "90736849096372", Name = "Right Leg", Offset = CFrame.Angles(0, 0,  Rad(90)), TextureId = "79186624401216" },
-- request
{ MeshId = "14768666349", Name = "Torso", Offset = CFrame.Angles(0, 0, 0), TextureId = "14768664565" },
{ MeshId = "14768684979", Names = { "Left Arm", "Right Arm"}, Offset = CFrame.Angles(0, 0, 1.57), TextureId = "14768683674" },

{ 
    MeshId = "16353867691", 
    TextureId = "16353884221", 
    Name = "Reanim_Sword", 
    Offset = CFrame.new(1.8, 1.8, 1) * CFrame.Angles(Rad(90), 100, Rad(90)), -- changed Rad -> math.rad
},
},
ApplyDescription = true,
BreakJointsDelay = 0.251,
ClickFling = false,
DefaultFlingOptions = {
HatFling = false,--{ MeshId="", TextureId = ""},
Highlight = true,
PredictionFling = true,
ToolFling = false,--"Boombox",
},
DisableCharacterCollisions = true,
DisableHealthBar = true,
DisableRigCollisions = true,
HatDrop = false,
HideCharacter = true,
ParentCharacter = true,
PermanentDeath = true,
Refit = true,
RigSize = 1,
RigTransparency = 1,
R15 = false,
SetCameraSubject = true,
SetCameraType = true,
SetCharacter = false,
SetCollisionGroup = true,
SimulationRadius = 2147483647,
TeleportRadius = 45,
})

wait(1 / 60)
Effects = { }
local script = game:GetObjects("rbxassetid://118891510380368")[1]
local Player = game.Players.localPlayer
local Mouse = Player:GetMouse()
local Character = workspace.non
local Humanoid = Character.Humanoid
local Head = Character.Head
local RootPart = Character.HumanoidRootPart
local Torso = Character.Torso
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Camera = game.Workspace.CurrentCamera
local RootJoint = RootPart.RootJoint
local Equipped = false
local Attack = false
local Anim = 'Idle'
local Idle = 0
local Combo = 1
local UIS = game:GetService("UserInputService")
local TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local Velocity = RootPart.Velocity.y
local Sine = 0
local Change = 1
local maincol = Color3.new(0,0,0)
local maincol2 = Torso.Color
local dash = false
humanoid = Humanoid
local taken = {}
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})

local function CreateWeld(Parent, Part0, Part1)
local Weld = Instance.new("Weld")
Weld.Parent = Parent
Weld.Part0 = Part0
Weld.Part1 = Part1
end

local function CreateWeldC(Parent, Part0, Part1)
local Weld = Instance.new("WeldConstraint")
Weld.Parent = Parent
Weld.Part0 = Part0
Weld.Part1 = Part1
end

local ReanimateMachete = Character:WaitForChild("Accessory (GonerSword)").Handle
ReanimateMachete.AccessoryWeld:Destroy()
local Machete = script.Weapons:WaitForChild("Machete"):Clone()
Machete:FindFirstChild("Machete").Transparency = 1
Machete.Parent = Character
Machete.Transparency =  1
Machete.CanTouch = true

local rightArm = Character["Right Arm"]
local offset = CFrame.new(0.1, -1, -1.15) * CFrame.Angles(0, math.rad(180), 0)
Machete.CFrame = rightArm.CFrame * offset
CreateWeldC(Character, rightArm, Machete, offset)


CreateWeld(Character, Machete, ReanimateMachete)

local function soundbork(obj)
if obj:IsA("Sound") and obj.Name ~= "aa" then
obj.Looped = false
obj.Pitch = 0
obj.Volume = 0
return
end


local children = obj:GetChildren()
for i = 1, #children do
soundbork(children[i])
end
return
end





local smonk1 = Instance.new("ParticleEmitter",Torso)
smonk1.LightEmission = .5
smonk1.Size = NumberSequence.new(0.2)
smonk1.Texture = "rbxassetid://95648201"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 2),NumberSequenceKeypoint.new(.2, 4),NumberSequenceKeypoint.new(.4, 6),NumberSequenceKeypoint.new(.564, 8),NumberSequenceKeypoint.new(.784, 10),NumberSequenceKeypoint.new(1, 10)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)})
smonk1.Transparency = bbb
smonk1.Size = aaa
smonk1.ZOffset = .5
smonk1.Acceleration = Vector3.new(0, 0, 0)
smonk1.LockedToPart = false
smonk1.EmissionDirection = "Top"
smonk1.Lifetime = NumberRange.new(8, 8)
smonk1.Rate = 2
smonk1.Rotation = NumberRange.new(0, 50)
smonk1.RotSpeed = NumberRange.new(50, 50)
smonk1.Speed = NumberRange.new(0)
smonk1.VelocitySpread = 0
smonk1.LockedToPart = true
smonk1.Enabled=false
local startColor = maincol
local endColor = maincol
local sequence = ColorSequence.new(startColor, endColor)
smonk1.Color = sequence

function Tween(obj,props,time,easing,direction,repeats,backwards)
local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
local tween = game:service'TweenService':Create(obj, info, props)

tween:Play()
end



FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local Create = FELOADLIBRARY.Create

prepareyourself=Instance.new("Sound", Character)
prepareyourself.SoundId = "rbxassetid://1810750535"
prepareyourself.Name = "aa"
prepareyourself.Volume = 3
prepareyourself.Looped = true
prepareyourself:Play()

beet=Instance.new("Sound", Torso)
beet.SoundId = "rbxassetid://826174965"
beet.Name = "aa"
beet.Looped = true
beet.Volume = 1
beet:Play()

humanoid.WalkSpeed = 8
humanoid.JumpPower = 0
humanoid.Animator.Parent = nil
Character.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
local w = Create('Motor'){
Parent = part0,
Part0 = part0,
Part1 = part1,
C0 = c0,
C1 = c1,
}
return w
end


function clerp(a, b, t)
return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
if bool == true then
if resetc1 == false then
resetc1 = true
RootJoint.C1 = RootJoint.C1
Torso.Neck.C1 = Torso.Neck.C1
RW.C1 = rarmc1
LW.C1 = larmc1
RH.C1 = rlegc1
LH.C1 = llegc1
end
end
end

ArtificialHB = Create("BindableEvent"){
Parent = Character,
Name = "Heartbeat",
}

Character:WaitForChild("Heartbeat")

frame = 1 / 45
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
Character.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
Character.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
Character.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)

function swait(num)
if num == 0 or num == nil then
ArtificialHB.Event:wait()
else
for i = 0, num do
ArtificialHB.Event:wait()
end
end
end

local m = Create("Model"){
Parent = Character,
Name = "WeaponModel"
}



function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

CFuncs = {	
Part = {
Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
local Part = Create("Part"){
Parent = Parent,
Reflectance = Reflectance,
Transparency = Transparency,
CanCollide = false,
Locked = true,
BrickColor = BrickColor.new(tostring(BColor)),
Name = Name,
Size = Size,
Material = Material,
}
RemoveOutlines(Part)
if Size == Vector3.new() then
Part.Size = Vector3.new(0.2, 0.2, 0.2)
else
Part.Size = Size
end
return Part
end;
};

Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh){
Parent = Part,
Offset = OffSet,
Scale = Scale,
}
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end;
};

Weld = {
Create = function(Parent, Part0, Part1, C0, C1)
local Weld = Create("Weld"){
Parent = Parent,
Part0 = Part0,
Part1 = Part1,
C0 = C0,
C1 = C1,
}
return Weld
end;
};

Sound = {
Create = function(id, par, vol, pit) 
local Sound = Create("Sound"){
Volume = vol,
Pitch = pit or 1,
Name = "aa",
SoundId = "rbxassetid://" .. id,
Parent = par or workspace,
}
Sound:play() 
return Sound
end;
};

Decal = {
Create = function(Color, Texture, Transparency, Name, Parent)
local Decal = Create("Decal"){
Color3 = Color,
Texture = "rbxassetid://" .. Texture,
Transparency = Transparency,
Name = Name,
Parent = Parent,
}
return Decal
end;
};

BillboardGui = {
Create = function(Parent, Image, Position, Size)
local BillPar = CFuncs.Part.Create(Parent, "SmoothPlastic", 0, 1, BrickColor.new("Black"), "BillboardGuiPart", Vector3.new(1, 1, 1))
BillPar.CFrame = CFrame.new(Position)
local Bill = Create("BillboardGui"){
Parent = BillPar,
Adornee = BillPar,
Size = UDim2.new(1, 0, 1, 0),
SizeOffset = Vector2.new(Size, Size),
}
local d = Create("ImageLabel", Bill){
Parent = Bill,
BackgroundTransparency = 1,
Size = UDim2.new(1, 0, 1, 0),
Image = "rbxassetid://" .. Image,
}
return BillPar
end
};

ParticleEmitter = {
Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
local Particle = Create("ParticleEmitter"){
Parent = Parent,
Color = ColorSequence.new(Color1, Color2),
LightEmission = LightEmission,
Size = Size,
Texture = Texture,
Transparency = Transparency,
ZOffset = ZOffset,
Acceleration = Accel,
Drag = Drag,
LockedToPart = LockedToPart,
VelocityInheritance = VelocityInheritance,
EmissionDirection = EmissionDirection,
Enabled = Enabled,
Lifetime = LifeTime,
Rate = Rate,
Rotation = Rotation,
RotSpeed = RotSpeed,
Speed = Speed,
VelocitySpread = VelocitySpread,
}
return Particle
end;
};

CreateTemplate = {

};
}

targetted = nil

--[[Credit to CKBackup for his lock-on script.--]]
function LockOn()
if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
TargetSelect(Mouse.Target.Parent)
print("Targeting")
print(Mouse.Target.Parent)
else end
end


function TargetSelect(person)
local dd=coroutine.wrap(function()
if targetted ~= person then
targetted = person
for i = 0,9,1 do
wait(.01)
end
end
end)
dd()
end

function RayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 


FindNearestTorso = function(pos)
local list = (game.Workspace:children())
local torso = nil
local dist = 1000
local temp, human, temp2 = nil, nil, nil
for x = 1, #list do
temp2 = list[x]
if temp2.className == "Model" and temp2.Name ~= Character.Name then
temp = temp2:findFirstChild("Torso")
human = temp2:findFirstChild("Humanoid")
if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
local dohit = true
if dohit == true then
torso = temp
dist = (temp.Position - pos).magnitude
end
end
end
end
return torso, dist
end

Laser = function(brickcolor, reflect, cframe, x1, y1, z1, x3, y3, z3, delay)

local prt = CFuncs.Part.Create(EffectModel, "Neon", reflect, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
prt.Anchored = true
prt.CFrame = cframe
prt.Material = "Neon"
local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
coroutine.resume(coroutine.create(function(Part, Mesh)

for i = 0, 1, delay do
swait()
Part.Transparency = i
Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
end
Part.Parent = nil
end
), prt, msh)
end




shoot = function(mouse, aoe , partt, SpreadAmount, multiply)

local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
local MainPos = partt.Position
local MainPos2 = mouse.Hit.p + SpreadVectors
local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
local speed = 1000
local num = 1
coroutine.resume(coroutine.create(function()

repeat
swait()
local hit, pos = RayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
local mag = (MainPos - pos).magnitude                                                            
Laser(BrickColor.new(maincol), 0, CFrame.new((MainPos + pos)/2, pos) * CFrame.Angles(1.57, 0, 0), 5, mag * (speed / (speed / 2)), 20, 20, 0, 20, 0.8)
MainPos = MainPos + MouseLook.lookVector * speed
num = num - 1
MouseLook = MouseLook * CFrame.Angles(math.rad(-1), 0, 0)
if hit ~= nil then
num = 0
local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
refpart.Anchored = true
refpart.CFrame = CFrame.new(pos)
game:GetService("Debris"):AddItem(refpart, 2)
end
do
if num <= 0 then
local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
refpart.Anchored = true
refpart.CFrame = CFrame.new(pos)
Effects.Block.Create(BrickColor.new(maincol), refpart.CFrame, 10, 10, 10, 10, 10, 10, .1, 1)
Effects.Break.Create(BrickColor.new(maincol), refpart.CFrame, 2, 10, 2)
if hit ~= nil then
MagnitudeDamage(refpart, aoe, 1.5 * multiply, 1.5 * multiply, 0, "Normal", "231917784", 0)
end
game:GetService("Debris"):AddItem(refpart, 0)
end
end
until num <= 0
end
))
end


Laser2 = function(brickcolor, reflect, cframe, x1, y1, z1, x3, y3, z3, delay)

local prt = CFuncs.Part.Create(EffectModel, "Neon", reflect, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
prt.Anchored = true
prt.CFrame = cframe
prt.Material = "Neon"
local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
coroutine.resume(coroutine.create(function(Part, Mesh)

for i = 0, 1, delay do
swait()
Part.Transparency = i
Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
end
Part.Parent = nil
end
), prt, msh)
end




shoot2 = function(mouse, aoe , partt, SpreadAmount, multiply)

local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
local MainPos = partt.Position
local MainPos2 = mouse.Hit.p + SpreadVectors
local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
local speed = 1000
local num = 1
coroutine.resume(coroutine.create(function()

repeat
swait()
local hit, pos = RayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
local mag = (MainPos - pos).magnitude                                                            
Laser2(BrickColor.new(maincol), 0, CFrame.new((MainPos + pos)/2, pos) * CFrame.Angles(1.57, 0, 0), 5, mag * (speed / (speed / 2)), .8, .8, 0, .8, 0.8)
MainPos = MainPos + MouseLook.lookVector * speed
num = num - 1
MouseLook = MouseLook * CFrame.Angles(math.rad(-1), 0, 0)
if hit ~= nil then
num = 0
local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
refpart.Anchored = true
refpart.CFrame = CFrame.new(pos)
game:GetService("Debris"):AddItem(refpart, 2)
end
do
if num <= 0 then
local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
refpart.Anchored = true
refpart.CFrame = CFrame.new(pos)
Effects.Block.Create(BrickColor.new(maincol), refpart.CFrame, 1, 1, 1, 1, 1, 1, .05, 1)
Effects.Break.Create(BrickColor.new(maincol), refpart.CFrame, .5, 3, .5)
if hit ~= nil then
MagnitudeDamage(refpart, aoe, 1.5 * multiply, 1.5 * multiply, 0, "Normal", "231917784", 0)
end
game:GetService("Debris"):AddItem(refpart, 0)
end
end
until num <= 0
end
))
end

function MagnitudeDamage(Part, Magnitude, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
for _, c in pairs(workspace:children()) do
local hum = c:findFirstChildOfClass("Humanoid")
if hum ~= nil then
local head = c:findFirstChild("Torso")
if head ~= nil then
local targ = head.Position - Part.Position
local mag = targ.magnitude
if mag <= Magnitude and c.Name ~= Character.Name and c.Name ~= Player.Name then
Empyrean.Fling(hum, {HatFling = false, Highlight = true, PredictionFling = true, ToolFling = false})
Effects.Lightning.Create(Part.Position, head.Position, 2, 5, "Really black", 1, 0, 3)
end
end
end
end
end


EffectModel = Create("Model"){
Parent = Character,
Name = "EffectModel",
}

Effects = {
Block = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
if Type == 1 or Type == nil then
table.insert(Effects, {
prt,
"Block1",
delay,
x3,
y3,
z3,
msh
})
elseif Type == 2 then
table.insert(Effects, {
prt,
"Block2",
delay,
x3,
y3,
z3,
msh
})
end
end;
};

Cylinder = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.2, 0.2, 0.2))
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 2)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end;
};

Head = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end;
};

Sphere1 = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "Glass", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end;
};

Sphere2 = {
Create = function(brickcolor, parent, cframe, x1, y1, z1, x3, y3, z3, delay)
if parent then
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
prt.Parent = parent
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end;
end
};

Elect = {
Create = function(cff, x, y, z)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, BrickColor.new(maincol), "Part", Vector3.new(1, 1, 1))
prt.Anchored = true
prt.CFrame = cff * CFrame.new(math.random(-x, x), math.random(-y, y), math.random(-z, z))
prt.CFrame = CFrame.new(prt.Position)
game:GetService("Debris"):AddItem(prt, 2)
local xval = math.random() / 2
local yval = math.random() / 2
local zval = math.random() / 2
local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
table.insert(Effects, {
prt,
"Elec",
0.1,
x,
y,
z,
xval,
yval,
zval
})
end;

};

Ring = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end;
};


Wave = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end;
};

Break = {
Create = function(brickcolor, cframe, x1, y1, z1)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
prt.Anchored = true
prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
local num = math.random(10, 50) / 1000
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Shatter",
num,
prt.CFrame,
math.random() - math.random(),
0,
math.random(50, 100) / 100
})
end;
};

Fire = {
Create = function(brickcolor, cframe, x1, y1, z1, delay)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Fire",
delay,
1,
1,
1,
msh
})
end;
};

FireWave = {
Create = function(brickcolor, cframe, x1, y1, z1)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 1, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
local d = Create("Decal"){
Parent = prt,
Texture = "rbxassetid://26356434",
Face = "Top",
}
local d = Create("Decal"){
Parent = prt,
Texture = "rbxassetid://26356434",
Face = "Bottom",
}
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"FireWave",
1,
30,
math.random(400, 600) / 100,
msh
})
end;
};

Lightning = {
Create = function(p0, p1, tym, ofs, col, th, tra, last)
local magz = (p0 - p1).magnitude
local curpos = p0
local trz = {
-ofs,
ofs
}
for i = 1, tym do
local li = CFuncs.Part.Create(EffectModel, "Neon", 0, tra or 0.4, col, "Ref", Vector3.new(th, th, magz / tym))
local ofz = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
local trolpos = CFrame.new(curpos, p1) * CFrame.new(0, 0, magz / tym).p + ofz
li.Material = "Neon"
if tym == i then
local magz2 = (curpos - p1).magnitude
li.Size = Vector3.new(th, th, magz2)
li.CFrame = CFrame.new(curpos, p1) * CFrame.new(0, 0, -magz2 / 2)
table.insert(Effects, {
li,
"Disappear",
last
})
else
do
do
li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / tym / 2)
curpos = li.CFrame * CFrame.new(0, 0, magz / tym / 2).p
game.Debris:AddItem(li, 10)
table.insert(Effects, {
li,
"Disappear",
last
})
end
end
end
end
end
};

EffectTemplate = {

};
}

--Intro
--[[
CFuncs.Sound.Create("1818153677", Character, 5, 1)
humanoid.WalkSpeed = 0	
Humanoid.AutoRotate = false
if Player.Name ~= "SezHu" then
for i = 0, 10, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(0, -1.80644357, -0.507104576, 1, 0, 0, 0, 0.087155968, 0.996194661, 0, -0.996194661, 0.087155968) * CFrame.new(0, 0, 0) * CFrame.Angles(0,0,0), 
CFrame.new(0, 1.57219315, -0.165327191, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-20,20)), math.rad(math.random(-20,20)), math.rad(math.random(-20,20))), 
CFrame.new(0.615828335, 1.3200798, -0.837673247, 0.669632733, 0.664489031, -0.331732333, 0.385775059, -0.692879617, -0.60917598, -0.634641349, 0.279950112, -0.720318198) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-20,20)), math.rad(math.random(-20,20)), math.rad(math.random(-20,20))), 
CFrame.new(-0.739693701, 1.31393027, -0.754651427, 0.749911249, -0.603388131, 0.271211922, -0.220070332, -0.614161789, -0.757874966, 0.623860657, 0.508653224, -0.593354702) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-20,20)), math.rad(math.random(-20,20)), math.rad(math.random(-20,20))), 
CFrame.new(0.5, -1.62046599, -0.488587797, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.6686697, -0.494725078, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end

for i = 0, 2, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(0, -1.80644476, -0.507115483, 1, 0, 0, 0, -0.087155968, 0.996194661, 0, -0.996194661, -0.087155968) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0, 1.55874133, -0.098664701, 1, 0, 0, 0, 0.99619478, 0.0871553123, 0, -0.0871553123, 0.99619478) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-20,20)), math.rad(math.random(-20,20)), math.rad(math.random(-20,20))), 
CFrame.new(0.615828335, 1.44548559, -0.595717013, 0.669632733, 0.664489031, -0.331732333, 0.490118831, -0.730966151, -0.474838912, -0.558010399, 0.155379415, -0.815157413) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-20,20)), math.rad(math.random(-20,20)), math.rad(math.random(-20,20))), 
CFrame.new(-0.739693701, 1.42501283, -0.515024424, 0.749911249, -0.603388131, 0.271211922, -0.325059503, -0.693158209, -0.643325806, 0.576167881, 0.394277275, -0.715944171) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-20,20)), math.rad(math.random(-20,20)), math.rad(math.random(-20,20))), 
CFrame.new(0.5, -1.51100469, -0.762556732, 1, 0, 0, 0, 0.996194661, -0.087155968, 0, 0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.55741048, -0.776971221, 1, 0, 0, 0, 0.996194661, -0.087155968, 0, 0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end

for i = 0, 8, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(0, -1.80644584, -0.507103682, 1, 0, 0, 0, -0.258818984, 0.965925872, 0, -0.965925872, -0.258818984) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0, 1.42364717, -0.0858392715, 1, 0, 0, 0, 0.965925872, 0.258819342, 0, -0.258819342, 0.965925872) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.615828335, 1.52697062, -0.335661292, 0.669632733, 0.664489031, -0.331732333, 0.579570174, -0.746842504, -0.326074779, -0.464424938, 0.0260881484, -0.885228276) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(-0.739693701, 1.49279666, -0.259749591, 0.749911249, -0.603388131, 0.271211922, -0.420171499, -0.75109303, -0.509230137, 0.510968745, 0.267921865, -0.816779613) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.5, -1.35563302, -1.01335466, 1, 0, 0, 0, 0.965925872, -0.258818984, 0, 0.258818984, 0.965925872) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.39883053, -1.03560853, 1, 0, 0, 0, 0.965925872, -0.258818984, 0, 0.258818984, 0.965925872) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end


for i = 0, 2, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(0, -1.80644584, -0.507103682, 1, 0, 0, 0, -0.258818984, 0.965925872, 0, -0.965925872, -0.258818984) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0, 1.42364717, -0.0858392715, 1, 0, 0, 0, 0.965925872, 0.258819342, 0, -0.258819342, 0.965925872) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.615828335, 1.52697062, -0.335661292, 0.669632733, 0.664489031, -0.331732333, 0.579570174, -0.746842504, -0.326074779, -0.464424938, 0.0260881484, -0.885228276) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(-0.739693701, 1.49279666, -0.259749591, 0.749911249, -0.603388131, 0.271211922, -0.420171499, -0.75109303, -0.509230137, 0.510968745, 0.267921865, -0.816779613) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.5, -1.35563302, -1.01335466, 1, 0, 0, 0, 0.965925872, -0.258818984, 0, 0.258818984, 0.965925872) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.39883053, -1.03560853, 1, 0, 0, 0, 0.965925872, -0.258818984, 0, 0.258818984, 0.965925872) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end
for i = 0, 6, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(0, -1.80644357, -0.507104576, 1, 0, 0, 0, 0.087155968, 0.996194661, 0, -0.996194661, 0.087155968) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0, 1.63373017, 0.0706499815, 1, 0, 0, 0, 0.965925932, -0.258818567, 0, 0.258818597, 0.965925932) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.615828335, 1.3200798, -0.837673247, 0.669632733, 0.664489031, -0.331732333, 0.385775059, -0.692879617, -0.60917598, -0.634641349, 0.279950112, -0.720318198) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(-0.739693701, 1.31393027, -0.754651427, 0.749911249, -0.603388131, 0.271211922, -0.220070332, -0.614161789, -0.757874966, 0.623860657, 0.508653224, -0.593354702) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.5, -1.62046599, -0.488587797, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.6686697, -0.494725078, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end


for i = 0, 10, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(0, -1.80644357, -0.507104576, 1, 0, 0, 0, 0.087155968, 0.996194661, 0, -0.996194661, 0.087155968) * CFrame.new(0, 0, 0) * CFrame.Angles(0,0,0), 
CFrame.new(0, 1.57219315, -0.165327191, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.615828335, 1.3200798, -0.837673247, 0.669632733, 0.664489031, -0.331732333, 0.385775059, -0.692879617, -0.60917598, -0.634641349, 0.279950112, -0.720318198) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(-0.739693701, 1.31393027, -0.754651427, 0.749911249, -0.603388131, 0.271211922, -0.220070332, -0.614161789, -0.757874966, 0.623860657, 0.508653224, -0.593354702) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-30,30)), math.rad(math.random(-30,30)), math.rad(math.random(-30,30))), 
CFrame.new(0.5, -1.62046599, -0.488587797, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.6686697, -0.494725078, 1, 0, 0, 0, 0.996194661, 0.087155968, 0, -0.087155968, 0.996194661) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end

for i = 0, 1, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(-0, -1.42307341, -0.395170838, 1, 0, 0, 0, 0.965926111, 0.25881803, 0, -0.25881803, 0.965926111) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0, 1.5574708, 0.0711615086, 1, 0, -0, 0, 0.906308413, -0.422617137, 0, 0.422617137, 0.906308413) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(1.47940862, 1.35474229, -0.0792688802, 0.0329260081, -0.0681179985, -0.997133851, 0.0255137086, -0.997292399, 0.0689713135, -0.999132156, -0.0277115256, -0.0310989153) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-1.42682672, 1.4937793, -0.434564888, -0.987767458, -0.0547382608, -0.146011457, 0.0626192689, -0.996787667, -0.0499334633, -0.142809138, -0.0584657788, 0.98802197) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0.5, -1.35469198, 1.14829361, 1, 0, 0, 0, 0.25881803, 0.965926111, 0, -0.965926111, 0.25881803) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.37694573, 1.19149125, 1, 0, 0, 0, 0.25881803, 0.965926111, 0, -0.965926111, 0.25881803) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end

for i = 0, 20, 0.1 do
swait()
PlayAnimationFromTable({
CFrame.new(-0, -1.73198283, -0.408192486, 1, 0, 0, 0, 0.965926111, 0.25881803, 0, -0.25881803, 0.965926111) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0, 1.52978098, 0.0132061839, 1, 0, 0, 0, 0.965926111, -0.25881803, 0, 0.25881803, 0.965926111) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(math.random(-20,20))), 
CFrame.new(1.50245035, -0.135501236, -0.426563323, 0.103369966, -0.0218989942, -0.994401932, -0.260855079, 0.964166582, -0.0483495258, 0.959827721, 0.264392674, 0.0939534009) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-10,10)), math.rad(math.random(-10,10)), math.rad(math.random(-10,10))), 
CFrame.new(-1.50386858, -0.0327540934, -0.608011007, -0.987763107, 0.0418113954, 0.150252879, 0.062630102, 0.988642037, 0.136617646, -0.142834127, 0.144356206, -0.979162872) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-10,10)), math.rad(math.random(-10,10)), math.rad(math.random(-10,10))), 
CFrame.new(0.5, -1.05967855, 1.24081683, 1, 0, 0, 0, 0.25881803, 0.965926111, 0, -0.965926111, 0.25881803) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.5, -1.08193231, 1.28401434, 1, 0, 0, 0, 0.25881803, 0.965926111, 0, -0.965926111, 0.25881803) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end
end
]]

local SINE = 1

Humanoid.AutoRotate = true
humanoid.WalkSpeed = 8
WingMain=CFuncs.Part.Create(m,Enum.Material.Plastic,0,1,"Medium stone grey","Wing",Vector3.new(2, 2, 1))
WingMainWeld=CFuncs.Weld.Create(m,Character["Torso"],WingMain,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.081413269, 0.0268063918, 0.0410137177, 1.00000834, -0.00011451864, 0.000338948274, 0.000117048308, 1, 1.29755635e-05, -0.00033910721, -1.32235973e-05, 1))
Wing=CFuncs.Part.Create(m,Enum.Material.Plastic,0,1,"Medium stone grey","Wing",Vector3.new(2, 2, 1))
WingWeld=CFuncs.Weld.Create(m,WingMain,Wing,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.081413269, 0.0268063918, 0.0410137177, 1.00000834, -0.00011451864, 0.000338948274, 0.000117048308, 1, 1.29755635e-05, -0.00033910721, -1.32235973e-05, 1)) 
local WingW = Instance.new("Weld", Character.Wing)
WingW.Part0 = Character.Wing
WingW.Part1 = Wing

local CanFling = false

function punch1()
    Attack = true
	CanFling = true
    -- First punch animation
    local anim1 = {
        CF(0,0.1*COS(SINE/12),0)*ANGLES(0,RAD(15),0),
        CF(0,1.5,0)*ANGLES(RAD(3*SIN(SINE/12)),RAD(-15),0),
        CF(1.5, 0.5, -0.1) * ANGLES(RAD(-300), RAD(3), RAD(60)) * CF(0, -0.5, 0),
        CF(-1.5,0,0),
        CF(0.5,-1.95-0.1*COS(SINE/1),0)*ANGLES(RAD(1),RAD(4),0),
        CF(-0.5,-1.95-0.1*COS(SINE/12),0)*ANGLES(0,RAD(5),0),
    }

    local anim2 = {
        CF(0,0.1*COS(SINE/12),0)*ANGLES(0,RAD(15),0),
        CF(0,1.5,0)*ANGLES(RAD(3*SIN(SINE/12)),RAD(-15),0),
        CF(1.5, 0.5, -0.1) * ANGLES(RAD(-265), RAD(5), RAD(-60)) * CF(0, -0.5, 0),
        CF(-1.5,0,0),
        CF(0.5,-1.95-0.1*COS(SINE/1),0)*ANGLES(RAD(1),RAD(4),0),
        CF(-0.5,-1.95-0.1*COS(SINE/12),0)*ANGLES(0,RAD(5),0),
    }

    -- play first animation over time
    local duration1 = 0.08
    local startTime = tick()
    while tick() - startTime < duration1 do
        PlayAnimationFromTable(anim1, 0.25, false) -- speed 0.2 for smooth interpolation
        task.wait()
    end

    -- play second animation over time
    local duration2 = 0.08
    local startTime2 = tick()
    while tick() - startTime2 < duration2 do
        PlayAnimationFromTable(anim2, 0.4, false)
        task.wait()
    end

CanFling = false
    Attack = false
end


RootPart.Touched:Connect(function(Hit)
if not CanFling then return end
if Hit:IsDescendantOf(Character) then return end
local Target = Hit.Parent
local TargetHumanoid = Target:FindFirstChildOfClass("Humanoid")
if TargetHumanoid then
--Empyrean.Fling(Hit, DefaultFlingOptions)
end
end)


Mouse.Button1Down:connect(function()
if Attack == false and Combo == 1 then
punch1()
Combo = 1
end
end)	


while true do
swait()
TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
Velocity = RootPart.Velocity.y
Sine = Sine + Change
local hit, pos = RayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
if RootPart.Velocity.y > 1 and hit == nil then 
Anim = "Jump"
if Attack == false then
Change = 1
PlayAnimationFromTable({
CFrame.new(-0.0142319221, 0.0233184248, 0.0206878185, 1.00000012, 1.49011612e-08, 0, 2.72463048e-08, 0.965925992, 0.258818656, 2.98023224e-08, -0.258818597, 0.965925932) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0.0172861218, 1.54588914, -0.00366462767, 0.999084175, 0.00742999092, -0.0421376228, -0.011074245, 0.996153653, -0.0869220346, 0.0413297117, 0.0873090774, 0.995323658) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(1.54051697, 0.254249156, -0.521965742, 0.890014946, -0.152965426, -0.429505706, -0.32768172, 0.440404594, -0.835864007, 0.317014515, 0.884672523, 0.341842651) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-1.55745959, 0.112057857, 0.343250573, 0.986049891, 0.113037676, 0.12218184, -0.158506706, 0.861737013, 0.481959641, -0.050808996, -0.49460274, 0.867632747) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0.566533923, -1.59700418, -0.481964171, 0.999206185, -0.0385679156, -0.00998616219, 0.0397087261, 0.94381088, 0.328091979, -0.00322881341, -0.328228056, 0.944592893) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.433014154, -1.95977831, 0.0051856637, 1, 0, 0, 0, 0.965925813, 0.258819401, -2.98023224e-08, -0.258819431, 0.965925753) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .1, false)
end
elseif RootPart.Velocity.y < -1 and hit == nil then 
Anim = "Fall"
if Attack == false then
Change = 1
PlayAnimationFromTable({
CFrame.new(-0.0142319212, 0.0233183783, 0.0206877608, 1.00000012, 1.49011612e-08, 2.98023224e-08, 2.72463048e-08, 0.984807968, 0.173647314, 2.98023224e-08, -0.17364724, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0.0154076805, 1.5522356, -0.0916171968, 0.999084175, 0.0180828422, -0.0387787819, -0.00742995739, 0.9658584, 0.258964151, 0.0421376526, -0.258438855, 0.965108156) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(1.44003379, 0.0510732532, -0.418421805, 0.890014946, -0.0760585517, -0.449542671, -0.298804998, 0.647417247, -0.701118112, 0.344367683, 0.75833106, 0.553484201) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-1.55745959, 0.141547889, 0.332177758, 0.986049891, 0.113037676, 0.12218184, -0.162331849, 0.815350056, 0.555745184, -0.036800772, -0.567826271, 0.822325349) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(0.573113441, -1.8059541, -0.374102622, 0.999206126, -0.0373207629, 0.0139417946, 0.0392762311, 0.98143959, -0.187706873, -0.00667765737, 0.188105404, 0.982126117) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-0.433013678, -1.95186841, 0.175973177, 1, 0, 2.98023224e-08, 0, 0.98480773, 0.173648328, 2.98023224e-08, -0.173648328, 0.984807789) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
}, .05, false)
end		
elseif TorsoVelocity < 1 and hit ~= nil then
Anim = "Idle"
if Attack == false then
Change = 1
PlayAnimationFromTable({
CF(0,0.1*COS(SINE/12),0)*ANGLES(0,RAD(15),0),
CFrame.new(0, 1.57220602, -0.165335596, 1, 0, 0, 0, 0.99619478, 0.0871558785, 0, -0.0871558785, 0.99619478) * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(-35,35)), 0, math.rad(math.random(-35,35))),
CF(1.5,0.4,0.17)*ANGLES(RAD(-10),RAD(-15),0)*CF(0,-0.5,0),
CF(-1.5,0,0),
CF(0.5,-1.95-0.1*COS(SINE/1),0)*ANGLES(RAD(1),RAD(4),0),
CF(-0.5,-1.95-0.1*COS(SINE/12),0)*ANGLES(0,RAD(5),0),
}, .05, false)
WingWeld.C0 = clerp(WingWeld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0 - 30 * math.cos(Sine/30)/2)), 0.1)
end
elseif TorsoVelocity > 2 and hit ~= nil then
Anim = "Walk"
if Attack == false then
SINE = SINE + 1
--[[
	RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
]]

PlayAnimationFromTable({
	CF(0,0.2*COS(SINE/5),0)*ANGLES(RAD(-2),RAD(-8-3*SIN(SINE/5)),0),
	CF(0,1.5,0)*ANGLES(RAD(-15),-RAD(-7+3*SIN(SINE/10)),0),
	--old offsets:
	--CF(1.5,0.5,0)*ANGLES(RAD(90),RAD(-15),0)*CF(0,-0.5,0),
    --CF(1.5,0.5,0)*ANGLES(0,RAD(35),RAD(-90))*CF(-1,0,0)
	--new offsets
	CF(1.5,0.4,0.17)*ANGLES(RAD(-10),RAD(-15),0)*CF(0,-0.5,0),
	CF(-1.5,0.5,0)*ANGLES(RAD(90),RAD(-15),0)*CF(0,-0.5,0),
	CF(0.54,-1.85-0.6*SIN(SINE/10),0.17+0.6*SIN(SINE/10))*ANGLES(0,RAD(-20),0)*ANGLES(RAD(-15+(45*COS(SINE/10))),0,0),
	CF(-0.53,-1.85+0.6*SIN(SINE/10),0.17-0.6*SIN(SINE/10))*ANGLES(0,RAD(-5),0)*ANGLES(RAD(-15-(45*COS(SINE/10))),0,0),
}, .05, false)
--RootJoint.C1 = Clerp(ROOTJOINT.C1, ROOTC0 * CF(0, 0, -0.015 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 * (HUM.WalkSpeed / 16) / ANIM_SPEED)
--Neck.C1 = Clerp(NECK.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - HEAD.RotVelocity.Y / 30), 0.2 * (HUM.WalkSpeed / 16) / ANIM_SPEED)
--H.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35 * COS(SINE / WALKSPEEDVALUE))), 0.6 / ANIM_SPEED)
---RH.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35 * COS(SINE / WALKSPEEDVALUE))), 0.6 / ANIM_SPEED)
--WingWeld.C0 = clerp(WingWeld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20 + 40 * math.cos(Sine/20)/2)), 0.1)
end
end
if #Effects > 0 then
for e = 1, #Effects do
if Effects[e] ~= nil then
local Thing = Effects[e]
if Thing ~= nil then
local Part = Thing[1]
local Mode = Thing[2]
local Delay = Thing[3]
local IncX = Thing[4]
local IncY = Thing[5]
if Thing[1].Transparency <= 1 then
if Thing[2] == "Block1" then
Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Ice" then
if Thing[6] <= Thing[5] then
Thing[6] = Thing[6] + .05
Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, .4, 0)
else
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
end
elseif Thing[2] == "Shatter" then
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
Thing[6] = Thing[6] + Thing[5]
elseif Thing[2] == "Block2" then
Thing[1].CFrame = Thing[1].CFrame
Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Block3" then
Thing[1].CFrame = Thing[8].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Block4" then
Thing[1].CFrame = Thing[8].CFrame * CFrame.new(0, -Thing[7].Scale.Y, 0) * CFrame.fromEulerAnglesXYZ(3.14, 0, 0)
Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Block2Fire" then
Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
if Thing[1].Transparency >= .3 then
Thing[1].BrickColor = BrickColor.new("Bright red")
else
Thing[1].BrickColor = BrickColor.new("Bright yellow")
end
elseif Thing[2] == "Cylinder" then
Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Blood" then
Mesh = Thing[7]
Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, -.5, 0)
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Elec" then
Mesh = Thing[10]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
Thing[1].CFrame = Thing[1].CFrame * Thing[11] * CFrame.new(0, 0, .2)
Thing[1].Rotation = Vector3.new(0, 0, 0)
elseif Thing[2] == "Disappear" then
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
end
else
Part.Parent = nil
table.remove(Effects, e)
end
end
end
end
end
if dash == true then
RootPart.Velocity = RootPart.CFrame.lookVector * 100
end
end
